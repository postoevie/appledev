Структурный параллелизм

Параллельный код организован в иерархию тасок (Task) как базовых элементов. Это позволяет просто передавать информацию между разными уровнями иерархии.
Асинхронные функции выполняются в таске последовательно.

Группы тасок определяют область в которой создаются дочерние таски. Создать группу можно методом withThrowingTaskGroup.
Дочерние таски наследуют некоторую метадату родительских(например, приоритет); могут существовать только в пределах группы и должны быть завершены к моменту выхода скоупа группы.

Добавленные в группу задачи завершить свое выполнение в произвольном порядке (т к выполняются параллельно).

За выполнение задач отвечают Executors, распределяя их по потокам. 

Отмена задач

Задачу можно отменить явно, вызывав метод cancel(). 
Также родительские задачи автоматически отменяются при выбросе ею ошибки (пришедшей, например, из дочерних задач) и отменяют дочерние.
Сама по себе отмена задачи не имеет никакого влияния на ход выполнения дочерних задач - что-то должно проверять состояние задачи.

Как в примере с нарезкой овощей в swift evolution - в группу задач добавлены две задачи. Первая выполняется до второй и выбрасывает ошибку.
Так как ошибка не обработана, происходит выход из контекста родительской задачи до того как выполнена вторая дочерняя. Такой выход отменяет родительскую и дочерние задачи. 
Но так как в структурном параллелизме дочерние задачи могут выполняться только в пределах родительских, не выходя за их скоуп, то выполнение не прекратится пока не закончит выполнение вторая задача. Однако, результат будет нивелирован. Чтобы этого избежать в коде задачи можно вызвать try Task.checkCancellation().


Неструктурные задачи

Можно создать и отдельную задачу без привязки к группе с помощью конструктора Task { ... }.
Результат выполнения можно получить так - let result = try await Task { ... }.value
Это можно использовать, например, при вызове методов интерактора/сервисов в презентере и дольнейшем обновлении UI через MainActor.

Хоть такие задачи и не имеют родителя, они все равно по умолчанию наследуют метадату из контекста, в котором созданы (например, приоритет). Детали о наследованной метадате можно посмотреть в evolution.

Чтобы создать задачу, независящую от контекста, нужно вызвать Task.detached {} .

https://github.com/swiftlang/swift-evolution/blob/main/proposals/0304-structured-concurrency.md
