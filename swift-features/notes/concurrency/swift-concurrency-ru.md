Асинхронная функция - та, которая может хранить стек вызова отдельно от потока вызвавшего ее и таким образом сменить поток выполнения. Это может произойти при встрече точки приостановки (suspension point) - функция останавливает выполнения на одном потоке и может продолжить его на другом. Любой вызов асинхронной функции - потенциальная точка приостановки. Вызов может быть произвден только в пределах другой асинхронной функции или в замыкании передаваемое в конструктор Task.

Thread explosion - явление при котором одновременно существуют большое количество потоков(в десятки раз превышающее количество ядер процессора).
Могут возникнуть, например, при работе с параллельной очередью. При блокировке одного потока (например вызовом sync другой очереди) и при наличии операций в очереди, будут создаваться новые потоки (чтобы ядра не простаивали), которые так же могут быть заблокированы, провоцируя создание новых потоков.
Потери в производительности вызывают необходимость хранения контекста и стека каждого потока, и многочесленные переключения между контекстами (процессорное время распределяется между потоками).

В Swift Concurrency, чтобы избежать этого, количество потоков не превышает количество ядер. Потоки не блокируются. Переключение между контекстами потоков заменяется на переключение между continuations (затраты - как вызов функции).

При вызове синхронной функции, ее фрейм добавляется в стек фреймов потока (фрейм содержит адрес возврата и локальные переменные).
При вызове асинхронной (async) функции, с указанием asynchronous wait (await, potential suspension point), ее фрейм копируется в continuation (стекс async фреймов), хранящийся в куче. Поток продолжает выполнение. При вызове другой async функции, вместо добавления нового фрейма, фрейм предыдущей заменяется на фрейм вызываемой, который так же копируется в continuation. Если эта другая функция приостанавливается (содержит suspension point), то поток, не будучи блокированным, берется выполнять другую произвольную работу. При этом, асинхронный стек вызовов хранится в куче и может быть использован для продолжения выполнения, тем же или другим потоком.

Continuation (код, что после вызова асинк функции) выполняется после выполнения асинхронной функции (т е существует зависимость, известна компилятору и рантайму). Другая зависимость - для завершения группы задач все дочерние таски должны быть завершены.
Таски (будь это continuation или task groups) могут асинхронно ожидать (await) только другие таски. Таким образом, выстраивается явная цепочка зависимостей между тасками.

Применение SC несет издержки (аллокейт в куче и логика рантайма), то есть должно быть оправдано и нужно профилировать код с инструментс.

Нельзя нарушать Runtime Contract - потоки не должны быть блокированы - это проверяется переменной среды libdispatch_coopeative_pool_strict

Синхронизация

Contention (конкуренция) - происходит при попытке выполнить sync задачу на последовательной очереди, если в данный момент на ней уже выполняется задача. Это может вызвать блокировку текущего потока (что является причиной thread explosion). Если очередь не выполняется, то текущий поток не заблокируется и будет использован для обработки задачи. 
Для этого рекомендовали использовать async, так как он не заблокирует текущий поток. Однако, при отсутствии contention, GCD запросит новый поток для выполнения асинхронной операции, пока текущий будет выполнять код следующий за асинхронным вызовом. Т е при частых вызовах async будет происходить и частые запуск потока и смена контекста(т к кол-во ядер ограничено). 

Акторы помогают избежать этих недостатков - когда происходит вызов на акторе, с которым не выполняется задача, то вызывающий поток может приостановить выполняемую функцию и взяться за другую работу.
Множество акторов работают с общим cooperate thread pool. Вместо блокировки/смены потоков, потоки меняеют акторов, на которых выполняются задачи - actor hopping.

В условиях, когда в очередях акторов стоит много задач и имеется конкуренция за потоки, играет роль приоритизация задач. Для последовательных очередей, чтобы избежать priority inversion (когда задача с более высоким приорити стоит после тех что с низким) происходит повышение приорити задачи стоящих перед приоритетной (чтобы сохранить семантику FIFO и выполнить задачу быстрее).
Другой подход - actor reentrancy
Задачи с актором, ожидающие выполнения, могут меняться местами, нарушая последовательность очереди и выполняя сначала более приоритетные задачи. При этом, эксклюзивность доступа сохраняется.

Существует отдельный актор, работающий с главной очередью - MainActor. Так как главный поток существует вне пула потоков, то при последовательном вызове задач на главном и других акторах, будет происходить переключение контекста. Например, при получении данных из актора БД, лучше получать их батчем и затем отрисовывать с главным актором, чтобы избежать частых переключений.

При применении стандартных Sequence операций к асинхронной последовательности (AsyncSequence), каждый последующий ее элемент оказывается доступным после выполнения асинхронной операции в next() итератора.


https://developer.apple.com/videos/play/wwdc2021/10254/
https://swiftrocks.com/how-async-await-works-internally-in-swift
https://liudasbar.medium.com/the-new-world-of-swift-concurrency-a-deep-dive-into-async-await-actors-and-more-e03ee9a72450
https://www.hackingwithswift.com/swift/5.5/async-sequences
